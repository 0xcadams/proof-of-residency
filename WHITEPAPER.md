# Proof of Residency Whitepaper

## Motivation

The web3 ecosystem has benefited from the anonymity and transparency of the underlying smart contracts. Many of the current protocols being developed are moving towards integrating real-world identity into web3, while maintaining privacy of the participating users.

Over the course of the next few decades, we will start realizing the benefits of decentralized proof of ownership, particularly in the real estate space. This project is a first step towards "Proof of Residency" - an initial attempt at proving someone resides in a geographic location, without revealing their exact location, or enough information to allow an external party to identify where the person resides.

## Approach

We employ ZK proofs to prove to a web3 application that a person resides in a geographical region.

Lob is a centralized service which allows physical mail to be sent from an API call. We use this as a core piece of the proof of residency, but acknowledge that the service could be compromised. We take steps to mitigate risk with their services, and plan to reduce dependency on this service by eventually incorporating other Address Verification services.

### User Residency Proof

First, in order to verify that a user resides at a longitude/latitude, we attempt to use multiple services, to ensure that compromising one does not pose a risk of fraud. The user must first connect their wallet to the dapp, and then input an address which they would like to prove residency at. They must then allow the dapp to request geolocation using the browser. This will provide the dapp with a longitude/latitude, which must be within 500m of the address which they input.

If they choose to continue to validate this physical address, they will be asked to input a password which will be used as a "seed extension" for a BIP39 mnemonic phrase.

This password is sent to the centralized backend API, which generates a BIP39 mnemonic and uses the user-provided password as the BIP39 passphrase. This BIP39 mnemonic (without the user-provided password) is sent to Lob, while the BIP39 mnemonic + user-provided password is used to create a public/private keypair. No information is stored in a centralized database. This ensures that Lob does not have enough information to be able to recreate the private/public key, since they are never aware of the password from the user. The centralized API does not record the user's password, so there is no way to verify the user's original request if they forget their password.

The in-memory private key is then used to sign a hash of the recipient alongside the normalized city, state, and country information.

```javascript
// privateKey would be generated from the above BIP39 mnemonic/password (similar to 0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318)
// recipient is set to the current account (via Metamask)
// city, state, and country are passed in from the response from Lob
const signAddressVerification = (privateKey, city, state, country) => {
  const recipient = web3.eth.defaultAccount;

  const hash = web3.utils.soliditySha3([recipient, city, state, country]).toString('hex');

  web3.eth.accounts.sign(hash, privateKey);
};
```

The signed message is then committed to a mapping on-chain, with a key that's set to the requesting address. To commit this transaction, the user pays a gas fee as well as a minimal ETH amount to cover the [costs of sending a letter through Lob](https://www.lob.com/pricing/print-mail) and development costs of the platform (this is a variable cost set by an owner of the contract, which is ideally as low as possible to support innovation on top of the platform).

#### Physical Mail

Once the user receives the letter with the BIP39 mnemonic, they now have all of the information they need to prove that they reside at the address in question. In the letter, are instructed to return back to the website and re-enter their claimed address, and then enter the remaining BIP39 words alongside their password to regenerate the public key. The public key and address components are then sent with the user's wallet address to the smart contract, where the mapping entry is queried.

The address parameters are then used to reconstruct the original signed message and the signer is verified to ensure that the message was signed with the original random BIP39 mnemonic generated by the backend.

If the signature is valid, then an NFT is minted with the city/state/country information.

### NFT

An NFT is issued with the metadata stored in IPFS. The IPFS URL is passed as the `tokenUri` for the ERC721 implementation. The structure of this metadata follows [OpenSea's standards](https://docs.opensea.io/docs/metadata-standards):

```json
{
  "description": "",
  "external_url": "ipfs://QmYoEmcoM23LqxUwza2erfopisrwErqWgTSgko34kWF7kA",
  "image": "ipfs://YkdpqrjcM23LqxUwza2erfopisrwErqWgTSgko34kWF7kA",
  "name": "Phoenix, AZ, USA",
  "tags": ["proof-of-residency"],
  "attributes": [
    {
      "trait_type": "State",
      "value": "Arizona"
    },
    {
      "trait_type": "City",
      "value": "Phoenix"
    },
    {
      "trait_type": "Country",
      "value": "United States of America"
    },
    {
      "trait_type": "Mail Sent Date",
      "value": 1546360800,
      "display_type": "date"
    }
  ]
}
```

### lk

https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
http://s2geometry.io/
https://www.lob.com/address-verification

https://whimsical.com/zk-proof-of-residency-VaktYWDAAv72HmvSot3wBQ

```

```

## Attack Vectors

- The first attack vector
